# School
<!-- toc -->
1. [CS 210](#cs210)
2. [CS 230](#cs230)
3. [CS 250](#cs250)
4. [CS 255](#cs255)
5. [CS 305](#cs305)
6. [CS 320](#cs320)
7. [CS 330](#cs330)
8. [CS 340](#cs340)

<!-- tocstop -->
## CS 210: Programming Languages <a name = "cs210"> </a>
The only project I've submitted thus far is the final project I completed for my CS 210 class with Dr. Chan.

In it, I was responsible for creating a program responsible for managing a zoo including functions which dictate adding animals among others.

The thing this project did well, far better than those in the past was to interact using all the tools collected throughout the class. 
Those tools include file I/O, language structure, interaction with a second language, and exception handling.
By using all these tools at once, I am able to better utilize this project as a series of notes that will remind me how to do these things in the future.
In addition, I am looking forward to showing my progress in the computer science program at SNHU by posting these projects.

While there are likely many ways I can improve the coding in this project, it is still too fresh in my mind for me to think of new ways. 
If I were to look back at Project 2 for this same class, I can think of an error I mad in the final display calculation in which I used a discrete value instead of a calculated one.
There may be very many errors I missed while progressing through the project that may not be compilation errors but runtime errors instead. 
These errors would result in improper construction of the system much like a faulty beam in a building may not be visible during initial construction.

When writing this code, one of my biggest hurdles was transitioning numbers to strings and vice versa.
In order to overcome this, I looked online on message boards and forums.
Before blindly choosing a function that would get me the result, I made sure to understand what it was doing and how.
If I were to blindly look up a function, I would not have understood exactly why the underlying transition would have worked or how the values may have changed along the way.

The skills learned and applied in this project that may be transferable to other courses include file I/O.
The use of files is one of the most important ones across languages as files store all the information we use on a daily basis, whether online or off.
Files and the attached filetypes are also going to impact the use of computer space as we move forward through the 21st century and the evolution of each language.

Comments are THE most important thing in any code.
They are responsible for providing portability, maintainability and the opportunity for future-proofing any project.
It was using the comments that I was able to adjust a copied java code into the c++ portion I used to construct the project.
It also helped that I understood at least a little of both languages, but without applying the comments I read I would not have been able to transfer the functions so easily.

## CS 230: Operating Platforms <a name = "cs230"> </a>
The most recent file is a software design document I've been working on in my operating systems class. 

As part of the curriculum, I and my classmates examined various parts of the three biggest operating systems in use today: Windows, Macintosh, and Linux.
For this assignment in particular, I must answer a series of questions, six to be precise. 

1. Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?

1a. The Gaming room is, to put it simply, a gaming company which currently has a game for android. They would like to see a functional prototype that could be launched on other platforms. 

2. What did you do particularly well in developing this document?

2a. Once I felt I had all the necessary information, I was able to more accurately define the advantages and weaknesses involved in launching it on the other platforms. After I did this, I was able to define the proper structure for the rest of the system's development. I believe that seeing the feedback from my instructor on previous iterations of the document, I was able to get the feedback I would have gotten from my team were this project more tangible in scope. The feedback proved necessary and seeing the document in action truly illustrated how necessary it is in the development community at large. 

3. What about the process of working through a design document did you find helpful when developing the code?

3a. By working through the document and receiving feedback about it from my instructor, a proxy for a  team lead, I was able to see what specific choices had on the overall project and how I needed to change them in order to truly meet the needs of the client. 

4. If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?

4a. As I was going over the document through different iterations, even before my instructor would return the graded version, I was revising the core statement. I kept changing and improving the goals of the software so that it was closer to what the client wanted. If this was a real world client, the ending product on the final iteration of the document would have been closer to what they actually wanted. If I were to revise it more today, the goals of the software would be what I would focus on so that they include the exact words requested by the client and an interpretation of them into a goal to be met by the team. 

5. How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?

5a. After the design document was constructed, design of the system was broken up into two separate parts: the client and the server designs. Once each section was made with relevant methods for each necessary task, I was able to test them. Although they did not build at first, feedback from my instructor, or team lead depending on how you look at it, was implemented to modify and improve the construction so it would build, compile, and was testable with the necessary components. After it was tested, we had a working prototype for the client in question. 

6. How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?

6a. My initial attempt implemented more features than were necessary or called for. This slowed down development times. I thought about it and considered how the application of system security played a part in the development. Once I did, I came to the conclusion that although security is important, it cannot come at the cost of overall system design. Therefore, the security implemented must be balanced with the client's needs and the level of privacy expected for the information contained therein. 

## CS 250: Software Development Lifecycle <a name = "cs250"> </a>
1. How do I interpret user needs and implement them into a program? How does creating “user stories” help with this?

1a. To look simply at user needs, we do not truly understand how to prioritize them according to a customer's needs; we may know for our own needs but not for a customer's. 
When we break down those needs into user stories that evaluate how a customer views them, we can prioritize them properly in the product backlog. This is further broken down into the sprint backlog or a kanban board or some other communication system being employed. 

2. How do I approach developing programs? What agile processes do I hope to incorporate into my future development work?

2a. After going through the class just a little bit, I thought about my own views on communication and how that played a role in development. The use of daily scrum meetings helps us to keep one another on track even though we may get distracted over time. The level of communication we see throughout the scrum framework allows us to not only stay on track but allow for the inevitable change. Not only that, but the scrum review allows us to show off what we've done so far to the client and any other notable personalities so that they may be the judge regarding needed updates or acceptance.  

3. What does it mean to be a good team member in software development?

3a. As I've touched on in many points, communication is the most important thing in a team setting, whether that's software development or a basketball team. What makes someone a good team member in my eyes is the ability to keep everyone up to date with what is happening. By doing this, any changes that need to happen can begin immediately instead of two weeks from now when the sprint is over. That is not to say that sending messages is the only important part of communication. It happens both ways. If said team member cannot receive or act on incoming messages, then those changes cannot effectively happen. 

## CS 255: System Analysis and Design <a name = "cs255"> </a>

1. Briefly summarize the DriverPass project. Who was the client? What type of system did they want you to design?

1a. DriverPass as a company was interested in improving student drivers' abilities to drive. My team was responsible for creating a website which could handle the finer points of that such as the schedule and the required roles and responsibilities of each person. 

2. What did you do particularly well?

2a. Based on the transcript which was provided, I was able to break down the client's requirements and communicate them to the development team.

3. If you could pick one part of these projects to revise, what would you pick and how would you do it?

3a. The system design document was a little rough when I was completing it. In it, I just stopped and thought about the details surrounding the system that I could think of. In a professional setting, I would hope that I could work with the other members of my team to write a longer list of requirements. They may seem like bad things but they turn the very fluid art of concision into a science that targets what customers are looking for. 

4. How did you interpret the user's needs and implement them into your design? Why is it so important to consider the user's needs when designing?

4a. One document that I constructed in preparation for the first assignment was a list of customer requirements based on the initial transcript. It ran down the list and covered things based on how they would be related. For example, I've got seven bullets that describe the process of reservations and appointments. Some of those same details made it into the UML class diagram. By rereading the transcript of the interview with the client, I was able to order the list into a set of requirements that guided me throughout the development process. If we do not consider the user's needs when designing, we could very well be wasting our time. 

5. How do you approach designing software? What techniques or strategies would you use in the future to analyze and design a system?

5a. The approach I took in this case was to break down the customer requirements. Once I did that, I was able to create the UML diagrams I could use to verify the customer's requirements and communicate the same to the rest of the team. 

## CS 305: Software Security <a name = "cs305"> </a>

1. Briefly summarize your client, Artemis Financial, and their software requirements. Who was the client? What issue did they want you to address?

1a. Artemis Financial was, like the name suggests, a financial holdings company who wanted to improve the security of their system.

2. What did you do particularly well in identifying their software security vulnerabilities? Why is it important to code securely? What value does software security add to a company’s overall wellbeing?

2a. By sticking to the basics, which in this case is the Vulnerabilities Assessment Process Flow Diagram, I was able to assess each particular area that made up the system. Once I did that, I was able to guide the company toward their goals. It is important to code securely because while the stakes may not always be as high as in this scenario, each organization still has its share of private information which could be bad if found in the wrong hands. If we do not do so, said private information could be lost in one form or another. Software security adds a level of trust to a company. For example, the greater the security in the system, the more information the public would trust in the organization. 

3. What about the process of working through the vulnerability assessment did you find challenging or helpful?

3a. Each classification had their own step. Were I to proceed through the collection of information and the possible security flaws on my own, I could find myself disorganized and a touch confused. By simply focusing on one step at a time, I was able to come to a more thorough understanding of the security needs of Artemis. 

4. How did you approach the need to increase layers of security? What techniques or strategies would you use in the future to assess vulnerabilities and determine mitigation techniques?

4a. I simply stepped through the diagram and asked myself, "How is this handled?" For example, in the case of the final project, no outside information came into the system, so no input validation was necessary. As there was no interface with which to work, I was able to move on to the cryptography of the system. Onward I went like that until I finished everything I could. Simply starting from the beginning and going slowly seemed like the way to go. Trying to go too quickly with security can easily create blind spots in the system.

5. How did you ensure the code and software application were functional and secure? After refactoring code, how did you check to see whether you introduced new vulnerabilities?

5a. In order to do this, I did something quite simple. I built and ran the program. If it didn't work properly, running it would expose that. With respect to the vulnerabilities, the dependency report would expose those. To prevent the code from creating new vulnerabilities, each new clause underwent the same vulnerability assessment as the initial mockup

6. What resources, tools, or coding practices did you employ that you might find helpful in future assignments or tasks?

6a. Internet searches, reviewing source material, and communication with those around me all presented some help with this. Staying skeptical of possible issues allowed me to think about them more frequently though which would easily present a new solution. 

7. Employers sometimes ask for examples of work that you have successfully completed to demonstrate your skills, knowledge, and experience. What from this particular assignment might you want to showcase to a future employer?

7a. In this assignment, I illustrate my ability to think critically about potential issues which may arise in a particular scenario. The understanding of issues before they arise in the public forum would save an organization time and money in development costs. 

## CS 320: Software Testing and Automation <a name = "cs320"> </a>

1. How can I ensure that my code, program, or software is functional and secure?

1a. Test coverage is quite possibly the most important benchmark when answering this question. It illustrates which branches are addressed and which are not. With respect to secure code particularly, no system is 100% secure. We can only test and defend against the threats we can think of. 

2. How do I interpret user needs and incorporate them into a program?

2a. The easiest way to do this is by making them into test cases. For example, Jeff the User wants to change his mouse icon. The actions of the mouse do not change, but simply the display of the mouse does. Will the requirement be restricted to the browser or require system permissions? Breaking down requirements into respective difficulties and security concerns will allow us to set up our test cases, which will then allow us better understanding so we know how to build moving forward. 

3. How do I approach designing software?

3a. Humans make mistakes. It's what we've done for as long as we've existed. Knowing how to remove error by working as a team or ensuring our large designs are well thought through is one of the best things we can do to make these things easier. Communication with your team, pair programming and test driven development are the most important parts of designing a system. When I first started the CS program, I didn't know what any of the three meant in this sense, but in going through the projects over the course of the last year, I can see the practical importance of each of them. 

## CS 330: Computer Graphics and Visualizations<a name = "cs330"> </a>

1. What new design skills has your work on the project helped you to craft?

1a. As part of the development process, I was able to better realize that some specialties are specialties for a reason. While I may understand what I am doing, even if I were to try my hand at what someone else does, it may not turn out nearly as well. In this instance, even though I should have had ample time to do so, I was not able to build it the way I expected to. 

2. What design process did you follow for your project work?

2a. Within each module, there were different tutorials that led us to understand different aspects of what we were trying to build. As I progressed through the course, I saw more and more of what was making the system behave the way it did. I tried to apply the design knowledge I could read to the separate sections I needed to build to get my final product. As I progressed, I faced issues, but without feeling like I had a team to really talk to, I tried my best to power through them. 

3. How could tactics from your design approach be applied in future work?

3a. Whether I am testing specific requirements, or checking the security requirements for a specific program, it helps to understand what the author is trying to say. Understanding the original approach makes it easier to correct any errors I may see during one of those checks. 

4. What new development strategies did you use while working on your 3D scene?

4a. As I was progressing through the various milestones that ultimately led to the grand project, I performed several iterations. Within those iterations, I had working versions that somewhat met requirements and others that didn't. Breaking down the differences in design choices allowed me to see why one thing worked while another didn't. 

5. How did iteration factor into your development?

5a. There were several steps in the final design process. Not every one led to success. As I performed each step, I saw what would work for me and why. I also what wouldn't work for me and investigated why. As I continued, I saw what would lead to the outcome received.

6. How has your approach to developing code evolved throughout the milestones, which led you to the project’s completion?

6a. Within each milestone, I further improved my understanding of modularity. Each separate clause created a different part of the picture. Understanding the separate clauses made it easier to understand the project and draw what I did. 

7. How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future educational pathway?

7a. While I may not particularly enjoy the work necessary in creating computer graphics, it gave me a greater appreciation for the level of work necessary by graphic designers who may say they have a particular timeline in place for a project of some kind. 

## CS 340: Client/Server Development <a name = "cs330"> </a>

#1. 
How do you write programs that are maintainable, readable, and adaptable? Especially consider your work on the CRUD Python module from Project One, which you used to connect the dashboard widgets to the database in Project Two. What were the advantages of working in this way?

#1a. 
What allowed me to do it properly was to modularize the code and break it up using comments so I could easily read what section went with what module. For example, the starter code broke up the code into the app layout, and app interaction sections. I went a step further to break it up into a datatable section, a map section and a pie section. From there, I can break up the program much more effectively. 

#2.  
How else could you use this CRUD Python module in the future?

#2a. 
Due to how it was broken up, I can use the separate modules in addition to the documentation to create graphs or maps in other projects which do not necessarily correspond to this one. 

#3. 
How do you approach a problem as a computer scientist? Consider how you approached the database or dashboard requirements that Grazioso Salvare requested. 

#3a. 
While it may appear otherwise on paper, a computer scientist is an artist. As such, there are often many ways to solve a problem at hand. All it takes in the end is to look over the source material. In this case and many others, that is the documentation of the language or related projects. Creating the documentation for this project is one of the requirements and as such has shown me the importance of creating well rounded and informative documentation.

#4. 
How did your approach to this project differ from previous assignments in other courses? 

#4a. 
In this project as opposed to others, I got quicker results by looking at the documentation of the methods or objects I was going to be creating. 
I feel I was quite fortunate that Dash had such thorough documentation and as such, I was able to create a higher quality project. 

#5. 
What techniques or strategies would you use in the future to create databases to meet other client requests?

#5a. 
Once I understood the documentation of MongoDB, I was able to create objects that fit within the form requested by the system. 
Maintaining that knowledge is not going to be easy and as a result, I have a copy of the knowledge I can use and reference later on if needed. 

#6. 
What do computer scientists do, and why does it matter? 

#6a.
Everything that computer scientists do revolves around data processing. 
Almost everything that our daily lives run on requires data processing in one form or another. 
Through a simple connection, it can be seen that almost everything in our daily lives requires computer scientists to process data and shape it into a form that will help us all.

#7. 
How would your work on this type of project help a company, like Grazioso Salvare, to do their work better?

#7a. 
This project, much like the others, was data processing. By creating filters that applied to the separate specialties, I was able to take what was an overabundance of data and turn it into a usable form.
